// ===========================================
// EXPORT SERVICE - Professional Data Export
// CSV, Excel, PDF with Branded Templates
// ===========================================

const ExportService = {
    // Branding configuration
    branding: {
        companyName: 'Lume MedSpa AI',
        logo: null, // Base64 or URL
        primaryColor: '#4F7DF3',
        accentColor: '#0F1629',
        footerText: 'Generated by Lume MedSpa AI â€¢ Confidential'
    },

    // ===========================================
    // CSV EXPORT
    // ===========================================

    /**
     * Export data to CSV with configurable columns
     * @param {Array} data - Array of objects to export
     * @param {Object} options - Export options
     * @returns {Blob} CSV file blob
     */
    toCSV(data, options = {}) {
        const {
            columns = null, // Array of column configs: { key, label, formatter }
            filename = 'export',
            includeHeaders = true,
            delimiter = ',',
            dateFormat = 'YYYY-MM-DD'
        } = options;

        if (!data || data.length === 0) {
            showToast('No data to export', 'warning');
            return null;
        }

        // Determine columns from data or options
        const cols = columns || Object.keys(data[0]).map(key => ({
            key,
            label: this.formatColumnLabel(key),
            formatter: null
        }));

        // Build CSV content
        let csv = '';

        // Headers
        if (includeHeaders) {
            csv += cols.map(c => this.escapeCSV(c.label)).join(delimiter) + '\n';
        }

        // Data rows
        data.forEach(row => {
            const values = cols.map(col => {
                let value = this.getNestedValue(row, col.key);

                // Apply formatter if provided
                if (col.formatter) {
                    value = col.formatter(value, row);
                } else if (value instanceof Date) {
                    value = this.formatDate(value, dateFormat);
                } else if (typeof value === 'object') {
                    value = JSON.stringify(value);
                }

                return this.escapeCSV(value);
            });
            csv += values.join(delimiter) + '\n';
        });

        // Create and download
        const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
        this.downloadBlob(blob, `${filename}.csv`);

        showToast(`Exported ${data.length} records to CSV`, 'success');
        return blob;
    },

    /**
     * Export clients to CSV with predefined columns
     */
    exportClientsToCSV(clients = null) {
        const data = clients || (ClientDataService ? ClientDataService.getAll() : []);

        return this.toCSV(data, {
            filename: `clients_export_${this.getDateStamp()}`,
            columns: [
                { key: 'id', label: 'Client ID' },
                { key: 'name', label: 'Full Name' },
                { key: 'email', label: 'Email' },
                { key: 'phone', label: 'Phone' },
                { key: 'membershipTier', label: 'Membership' },
                { key: 'healthScore', label: 'Health Score' },
                { key: 'churnRisk', label: 'Churn Risk %' },
                { key: 'lastVisit', label: 'Last Visit', formatter: v => this.formatDate(v) },
                { key: 'totalSpent', label: 'Total Spent', formatter: v => `$${(v || 0).toLocaleString()}` },
                { key: 'visitCount', label: 'Visit Count' },
                { key: 'treatments', label: 'Treatments', formatter: v => (v || []).join('; ') }
            ]
        });
    },

    // ===========================================
    // EXCEL EXPORT (Using SheetJS-like approach)
    // ===========================================

    /**
     * Export to Excel with multiple sheets and styling
     * @param {Object} options - Export options with sheets config
     */
    async toExcel(options = {}) {
        const {
            filename = 'export',
            sheets = [],
            includeMetadata = true
        } = options;

        // Create workbook structure
        const workbook = {
            sheets: [],
            metadata: {
                created: new Date().toISOString(),
                creator: this.branding.companyName,
                title: filename
            }
        };

        // Process each sheet
        sheets.forEach(sheet => {
            const sheetData = this.processSheetData(sheet);
            workbook.sheets.push(sheetData);
        });

        // Generate Excel-compatible XML (simplified XLSX format)
        const xlsxContent = this.generateExcelXML(workbook);

        const blob = new Blob([xlsxContent], {
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        });

        this.downloadBlob(blob, `${filename}.xlsx`);
        showToast(`Exported to Excel successfully`, 'success');
        return blob;
    },

    /**
     * Export clients report to Excel with summary
     */
    exportClientsToExcel(clients = null) {
        const data = clients || (ClientDataService ? ClientDataService.getAll() : []);

        // Calculate summary stats
        const summary = this.calculateClientSummary(data);

        return this.toExcel({
            filename: `clients_report_${this.getDateStamp()}`,
            sheets: [
                {
                    name: 'Summary',
                    type: 'summary',
                    data: summary
                },
                {
                    name: 'Client Details',
                    type: 'table',
                    data: data,
                    columns: [
                        { key: 'name', label: 'Name', width: 25 },
                        { key: 'email', label: 'Email', width: 30 },
                        { key: 'membershipTier', label: 'Tier', width: 15 },
                        { key: 'healthScore', label: 'Health', width: 10 },
                        { key: 'churnRisk', label: 'Churn %', width: 10 },
                        { key: 'totalSpent', label: 'Revenue', width: 15 }
                    ]
                },
                {
                    name: 'At-Risk Clients',
                    type: 'table',
                    data: data.filter(c => c.churnRisk >= 50),
                    columns: [
                        { key: 'name', label: 'Name', width: 25 },
                        { key: 'churnRisk', label: 'Churn Risk %', width: 15 },
                        { key: 'lastVisit', label: 'Last Visit', width: 15 },
                        { key: 'healthScore', label: 'Health Score', width: 12 }
                    ]
                }
            ]
        });
    },

    // ===========================================
    // PDF EXPORT (Using jsPDF-like approach)
    // ===========================================

    /**
     * Export to PDF with branded template
     * @param {Object} options - PDF options
     */
    async toPDF(options = {}) {
        const {
            filename = 'report',
            title = 'Report',
            subtitle = '',
            sections = [],
            orientation = 'portrait', // portrait or landscape
            includeCharts = false
        } = options;

        // Initialize PDF document structure
        const doc = {
            pages: [],
            currentPage: null,
            y: 0,
            pageWidth: orientation === 'portrait' ? 595 : 842,
            pageHeight: orientation === 'portrait' ? 842 : 595,
            margin: 40
        };

        // Add first page with header
        this.addPDFPage(doc);
        this.addPDFHeader(doc, title, subtitle);

        // Process sections
        sections.forEach(section => {
            this.addPDFSection(doc, section);
        });

        // Add footer to all pages
        this.addPDFFooters(doc);

        // Generate PDF content (simplified - in production use jsPDF)
        const pdfContent = this.generatePDFContent(doc);

        // For demo, create an HTML-based print view
        this.openPDFPrintView(doc, title, sections);

        showToast(`PDF report generated`, 'success');
    },

    /**
     * Export client report to PDF
     */
    exportClientsToPDF(clients = null) {
        const data = clients || (ClientDataService ? ClientDataService.getAll() : []);
        const summary = this.calculateClientSummary(data);
        const atRisk = data.filter(c => c.churnRisk >= 50).sort((a, b) => b.churnRisk - a.churnRisk);

        return this.toPDF({
            filename: `client_report_${this.getDateStamp()}`,
            title: 'Client Health Report',
            subtitle: `Generated ${new Date().toLocaleDateString()}`,
            sections: [
                {
                    type: 'metrics',
                    title: 'Executive Summary',
                    metrics: [
                        { label: 'Total Clients', value: summary.totalClients },
                        { label: 'Average Health', value: `${summary.avgHealth}%` },
                        { label: 'At-Risk Clients', value: summary.atRiskCount },
                        { label: 'Total Revenue', value: `$${summary.totalRevenue.toLocaleString()}` }
                    ]
                },
                {
                    type: 'table',
                    title: 'At-Risk Clients Requiring Attention',
                    data: atRisk.slice(0, 10),
                    columns: ['name', 'churnRisk', 'lastVisit', 'healthScore']
                },
                {
                    type: 'chart',
                    title: 'Client Health Distribution',
                    chartType: 'pie',
                    data: summary.healthDistribution
                }
            ]
        });
    },

    // ===========================================
    // HELPER METHODS
    // ===========================================

    escapeCSV(value) {
        if (value === null || value === undefined) return '';
        const str = String(value);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
    },

    getNestedValue(obj, path) {
        return path.split('.').reduce((acc, part) => acc && acc[part], obj);
    },

    formatColumnLabel(key) {
        return key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .trim();
    },

    formatDate(date, format = 'YYYY-MM-DD') {
        if (!date) return '';
        const d = new Date(date);
        if (isNaN(d.getTime())) return '';

        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');

        return format
            .replace('YYYY', year)
            .replace('MM', month)
            .replace('DD', day);
    },

    getDateStamp() {
        return new Date().toISOString().split('T')[0];
    },

    downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },

    calculateClientSummary(clients) {
        const total = clients.length;
        const atRisk = clients.filter(c => c.churnRisk >= 50).length;
        const avgHealth = total ? Math.round(clients.reduce((sum, c) => sum + (c.healthScore || 0), 0) / total) : 0;
        const totalRevenue = clients.reduce((sum, c) => sum + (c.totalSpent || 0), 0);

        // Health distribution
        const healthDistribution = {
            excellent: clients.filter(c => c.healthScore >= 80).length,
            good: clients.filter(c => c.healthScore >= 60 && c.healthScore < 80).length,
            fair: clients.filter(c => c.healthScore >= 40 && c.healthScore < 60).length,
            poor: clients.filter(c => c.healthScore < 40).length
        };

        return { totalClients: total, atRiskCount: atRisk, avgHealth, totalRevenue, healthDistribution };
    },

    processSheetData(sheet) {
        // Convert sheet config to table format
        return {
            name: sheet.name,
            rows: sheet.data.map(row => {
                if (sheet.columns) {
                    return sheet.columns.map(col => {
                        const value = row[col.key];
                        return col.formatter ? col.formatter(value) : value;
                    });
                }
                return Object.values(row);
            }),
            headers: sheet.columns ? sheet.columns.map(c => c.label) : null
        };
    },

    generateExcelXML(workbook) {
        // Simplified Excel XML for demo
        // In production, use SheetJS (xlsx) library
        let xml = '<?xml version="1.0"?>\n';
        xml += '<?mso-application progid="Excel.Sheet"?>\n';
        xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet">\n';

        workbook.sheets.forEach(sheet => {
            xml += `<Worksheet ss:Name="${sheet.name}">\n<Table>\n`;
            if (sheet.headers) {
                xml += '<Row>' + sheet.headers.map(h => `<Cell><Data ss:Type="String">${h}</Data></Cell>`).join('') + '</Row>\n';
            }
            sheet.rows.forEach(row => {
                xml += '<Row>' + row.map(cell => {
                    const type = typeof cell === 'number' ? 'Number' : 'String';
                    return `<Cell><Data ss:Type="${type}">${cell ?? ''}</Data></Cell>`;
                }).join('') + '</Row>\n';
            });
            xml += '</Table>\n</Worksheet>\n';
        });

        xml += '</Workbook>';
        return xml;
    },

    addPDFPage(doc) {
        doc.pages.push({ elements: [] });
        doc.currentPage = doc.pages[doc.pages.length - 1];
        doc.y = doc.margin;
    },

    addPDFHeader(doc, title, subtitle) {
        doc.currentPage.elements.push({
            type: 'header',
            title,
            subtitle,
            branding: this.branding
        });
        doc.y += 80;
    },

    addPDFSection(doc, section) {
        doc.currentPage.elements.push(section);
        doc.y += 150; // Estimate section height

        // Add new page if needed
        if (doc.y > doc.pageHeight - 100) {
            this.addPDFPage(doc);
        }
    },

    addPDFFooters(doc) {
        doc.pages.forEach((page, i) => {
            page.elements.push({
                type: 'footer',
                text: this.branding.footerText,
                pageNumber: `Page ${i + 1} of ${doc.pages.length}`
            });
        });
    },

    generatePDFContent(doc) {
        // Placeholder - in production use jsPDF
        return JSON.stringify(doc);
    },

    openPDFPrintView(doc, title, sections) {
        // Create print-friendly HTML view
        const printWindow = window.open('', '_blank');

        let html = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>${title}</title>
                <style>
                    @page { margin: 20mm; }
                    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: #1a1a2e; }
                    .header { text-align: center; border-bottom: 2px solid ${this.branding.primaryColor}; padding-bottom: 20px; margin-bottom: 30px; }
                    .header h1 { color: ${this.branding.accentColor}; margin: 0; font-size: 28px; }
                    .header .subtitle { color: #666; margin-top: 5px; }
                    .header .brand { color: ${this.branding.primaryColor}; font-size: 12px; margin-top: 10px; }
                    .section { margin-bottom: 30px; page-break-inside: avoid; }
                    .section h2 { color: ${this.branding.accentColor}; font-size: 18px; border-bottom: 1px solid #ddd; padding-bottom: 8px; }
                    .metrics { display: flex; gap: 20px; flex-wrap: wrap; }
                    .metric { background: #f5f7fa; padding: 15px 25px; border-radius: 8px; text-align: center; min-width: 120px; }
                    .metric .value { font-size: 28px; font-weight: bold; color: ${this.branding.primaryColor}; }
                    .metric .label { font-size: 12px; color: #666; margin-top: 5px; }
                    table { width: 100%; border-collapse: collapse; font-size: 12px; }
                    th { background: ${this.branding.accentColor}; color: white; padding: 10px; text-align: left; }
                    td { padding: 8px 10px; border-bottom: 1px solid #eee; }
                    tr:nth-child(even) { background: #f9f9f9; }
                    .footer { text-align: center; color: #999; font-size: 10px; margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; }
                    @media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>${title}</h1>
                    <div class="subtitle">Generated ${new Date().toLocaleDateString()}</div>
                    <div class="brand">${this.branding.companyName}</div>
                </div>
        `;

        sections.forEach(section => {
            html += `<div class="section"><h2>${section.title}</h2>`;

            if (section.type === 'metrics') {
                html += '<div class="metrics">';
                section.metrics.forEach(m => {
                    html += `<div class="metric"><div class="value">${m.value}</div><div class="label">${m.label}</div></div>`;
                });
                html += '</div>';
            } else if (section.type === 'table' && section.data.length > 0) {
                const cols = section.columns || Object.keys(section.data[0]);
                html += '<table><thead><tr>';
                cols.forEach(col => html += `<th>${this.formatColumnLabel(col)}</th>`);
                html += '</tr></thead><tbody>';
                section.data.forEach(row => {
                    html += '<tr>';
                    cols.forEach(col => html += `<td>${row[col] ?? ''}</td>`);
                    html += '</tr>';
                });
                html += '</tbody></table>';
            }

            html += '</div>';
        });

        html += `
                <div class="footer">${this.branding.footerText}</div>
                <script>setTimeout(() => window.print(), 500);</script>
            </body>
            </html>
        `;

        printWindow.document.write(html);
        printWindow.document.close();
    }
};

// Expose globally
window.ExportService = ExportService;

// Quick export functions
window.exportClientsCSV = () => ExportService.exportClientsToCSV();
window.exportClientsExcel = () => ExportService.exportClientsToExcel();
window.exportClientsPDF = () => ExportService.exportClientsToPDF();
